# Java内存模型

## 抽象结构

Java线程通信由JMM控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。

抽象说：线程之间的共享变量存储在主存中，每个线程都有一个私有的本地内存（物理上不存在）

线程A，B通信：

1. 线程A把本地内存A中更新过的共享变量刷新到主内存。
2. 线程B从主内存中读取线程A之前已经更新过的共享变量。

## 并发编程模型

现代处理器使用写缓冲区临时保存写入内存的数据，以批处理形式刷新，合并对同一地址的多次写，减少内存总线的占用。但每个处理器上的写缓冲区仅对所处的处理器可见。所以处理器对内存的读写执行顺序不一定与实际发生的顺序一致。

为保障内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来进制特定类型的处理器重排序。内存屏障共分为4类：

| 屏障类型   | 示例                     | 说明                                                         |
| ---------- | ------------------------ | ------------------------------------------------------------ |
| LoadLoad   | Load1; LoadLoad;Load2    | 1的装载先于2及后续指令                                       |
| StoreStore | Store1;StoreStore;Store2 | 1数据对其他处理器（刷新到内存）可见先于2的存储               |
| LoadStore  | Load1;LoadStore;Store2   | 1数据装载先于2及后续刷新到内存                               |
| StoreLoad  | Store1;StoreLoad;Load2   | 1数据对刷新到内存先于2及后续装载，该屏障之前的所有存储装载指令完成后才会执行该屏障后的内存访问指令。 |

StoreLoad同时具有其他3个屏障的效果，但开销很高。

## 重排序

为提高性能，编译器和处理器会进行指令重排序。分为三种（2,3）称为处理器重排序。

1. 编译器优化
2. 指令级并行
3. 内存系统重排序

对于处理器重排，JMM要求Java编译器生成指令序列前，插入特定类型的内存屏障指令，来禁止特定类型的处理器重排序。

### happens-before

JMM中，如果一个操作执行的结果需要对另一个操作可见，则两个操作之间必须要存在happens-before关系。(可以不同线程)

* 程序顺序：一个线程的每个操作,happen-before于该线程的任意后续操作
* 监视器锁：对一个锁的解锁，happen-before于随后对这个锁的加锁
* volatile变量：对一个volatile域的写，happen-before于后续的读
* 传递性：如果A happen-before B，B happen-before C，则A happen-before C

happen-before不是指前一个操作必须要在后一个操作之前执行，而是前一个操作对后一个操作可见，且前一个操作按顺序排在第二个之前。

### 数据依赖性

若两个操作同时访问一个变量，且其中有一个写操作，则两个操作存在数据依赖性。重排序时会遵守数据依赖性。此处的数据依赖性进制单个处理器中的指令序列和单个线程的操作。

### as-if-serial

不管怎么重排序，程序的执行结果不能被改变。为了遵守此语义，不会对存在数据依赖关系的操作重排序。

### 程序顺序规则

## 顺序一致性

如果程序是正确同步的，则具有顺序一致性——执行结果和在顺序一致性内存模型中的执行结果相同。

### 顺序一致内存模型

理想的参考模型，提供了极强的内存可见性保证。有两大特征:

1. 一个线程的所有操作必须按照程序的顺序来执行
2. 不管是否同步，所有线程都只能看到单一的操作执行顺序，顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。

JMM中没有此保证，即未同步程序在JMM中不但整体是无序的，而且所有线程看到的顺序也不一致。

## volatile

